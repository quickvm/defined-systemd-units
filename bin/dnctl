#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
#
# Copyright (c) 2025 QuickVM, LLC <contact@quickvm.com> All Rights Reserved.

set -e

# Load variables from env
: ${DN_API_KEY:-}
: ${DN_NETWORK_ID:-}
: ${DN_ROLE_ID:-}
: ${DN_IP_ADDRESS:-}
: ${DN_SKIP_UNENROLL:="false"}
: ${DN_MIRROR_IP:="false"}
: ${DN_NETWORK_NAME:=defined}
: ${DN_HOSTNAME:-}
: ${DN_CLOUD_PROVIDER:-}
: ${DN_STATIC_ADDRESSES:-}
: ${DN_LISTEN_PORT:-}
: ${DN_IS_LIGHTHOUSE:="false"}
: ${DN_IS_RELAY:="false"}
: ${DN_UNENROLL_ON_REBOOT:="false"}

# Load variables from /etc/defined/dnctl if it exists
if [[ -f /etc/defined/dnctl ]]; then
    source /etc/defined/dnctl
fi

if [[ "${DN_MIRROR_IP}" == "true" ]]; then
DEFAULT_ROUTE_IP=$(ip -j -4 route show|jq -rM '.[] |select(.dst == "default").prefsrc')
LAST_OCTET=$(echo $DEFAULT_ROUTE_IP |cut -d. -f4)
DN_NETWORK_CIDR=$(curl -sL "https://api.defined.net/v1/networks/${DN_NETWORK_ID}" -H "Accept: application/json" -H "Authorization: Bearer ${DN_API_KEY}" | jq -r .data.cidr |cut -d / -f1|cut -d. -f 1-3)

export DN_IP_ADDRESS="${DN_NETWORK_CIDR}.${LAST_OCTET}"

    # Check if DN_IP_ADDRESS is already defined in /etc/defined/dnctl
    if ! grep -q '^DN_IP_ADDRESS=' /etc/defined/dnctl 2>/dev/null; then
        echo "DN_IP_ADDRESS=${DN_IP_ADDRESS}" >> /etc/defined/dnctl
    fi
fi

# Detect if system is rebooting (vs shutting down)
is_rebooting(){
    # Method 1: Check systemd job queue for reboot.target
    if systemctl list-jobs 2>/dev/null | grep -q 'reboot.target'; then
        return 0
    fi

    # Method 2: Check scheduled shutdown file
    if [[ -f /run/systemd/shutdown/scheduled ]]; then
        if grep -q '^MODE=reboot' /run/systemd/shutdown/scheduled; then
            return 0
        fi
    fi

    return 1
}

# Fetch cloud instance ID based on provider
get_instance_id(){
    local provider="$1"
    local instance_id=""

    case "${provider}" in
        aws)
            # AWS IMDSv2 - get token first, then instance ID
            local token
            token=$(curl -s -X PUT "http://169.254.169.254/latest/api/token" \
                -H "X-aws-ec2-metadata-token-ttl-seconds: 21600" \
                --connect-timeout 2 2>/dev/null) || return 1
            instance_id=$(curl -s -H "X-aws-ec2-metadata-token: ${token}" \
                "http://169.254.169.254/latest/meta-data/instance-id" \
                --connect-timeout 2 2>/dev/null) || return 1
            # Strip "i-" prefix
            echo "${instance_id#i-}"
            ;;
        gcp)
            # GCP metadata endpoint
            instance_id=$(curl -s -H "Metadata-Flavor: Google" \
                "http://metadata.google.internal/computeMetadata/v1/instance/id" \
                --connect-timeout 2 2>/dev/null) || return 1
            echo "${instance_id}"
            ;;
        azure)
            # Azure IMDS endpoint - use first segment of UUID
            instance_id=$(curl -s -H "Metadata: true" \
                "http://169.254.169.254/metadata/instance/compute/vmId?api-version=2021-02-01&format=text" \
                --connect-timeout 2 2>/dev/null) || return 1
            echo "${instance_id%%-*}"
            ;;
        *)
            echo "Unknown cloud provider: ${provider}" >&2
            return 1
            ;;
    esac
}

install_dnclient(){
OS_ARCH=$(arch)
OS_TYPE=$(uname)

[[ "${OS_TYPE}" == "Linux" ]] || { echo "Only Linux is supported!"; exit 1; }

case "${OS_ARCH}" in
    aarch64) ARCH="arm64" ;;
    armv5*) ARCH="armv5" ;;
    armv6*) ARCH="armv6" ;;
    armv7*) ARCH="armv7" ;;
    i386) ARCH="386" ;;
    i686) ARCH="386" ;;
    x86_64) ARCH="amd64" ;;
    x86) ARCH="386" ;;
    *) ARCH="unknown" ;;
esac

[[ "${ARCH}" != "unknown" ]] || { echo "Unknown CPU arch!"; exit 1; }

export OSARCH="$(echo ${OS_TYPE}|sed -e 's/Linux/linux/g')-${ARCH}"

: ${BIN_DIR:=/usr/local/bin}
: ${DEFINEDPATH:=/etc/defined}
: ${DN_VERSION:="latest"}

DN_DOWNLOAD_URL=$(curl -sL https://api.defined.net/v1/downloads | jq --arg osarch "${OSARCH}" --arg version "${DN_VERSION}" -r '.data.dnclient|.[ $version ]|.[ $osarch ]')

mkdir -p "${DEFINEDPATH}"

if [[ -f ${BIN_DIR}/dnclient ]]; then
    echo "${BIN_DIR}/dnclient is already installed!"
    echo "Skipping dnclient download and install..."
else
    echo "Downloading dnclient from ${DN_DOWNLOAD_URL}..."
    curl -sSL ${DN_DOWNLOAD_URL} -o ${BIN_DIR}/dnclient && chmod +x ${BIN_DIR}/dnclient
    echo "dnclient installed successfully to ${BIN_DIR}/dnclient"
fi
}

# Determine service name and config path based on DN_NETWORK_NAME
SERVICE_NAME="dnclient@${DN_NETWORK_NAME}.service"
CONFIG_PATH="/etc/defined/${DN_NETWORK_NAME}/dnclient.yml"

start(){
    systemctl start "$SERVICE_NAME"
}

stop(){
    systemctl stop "$SERVICE_NAME"
}

restart(){
    systemctl restart "$SERVICE_NAME"
}

enable(){
    systemctl enable "$SERVICE_NAME"
}

write_config(){
    if [[ -f /etc/defined/dnctl ]]; then
        echo "The file /etc/defined/dnctl exists! Delete it to write a new dnctl configuration file."
        return 1
    fi

    cat << EOF > /etc/defined/dnctl
DN_API_KEY=${DN_API_KEY}
DN_NETWORK_ID=${DN_NETWORK_ID}
DN_ROLE_ID=${DN_ROLE_ID}
DN_SKIP_UNENROLL=${DN_SKIP_UNENROLL}
DN_UNENROLL_ON_REBOOT=${DN_UNENROLL_ON_REBOOT}
EOF

    if [[ "${DN_IP_ADDRESS}" ]]; then
        cat << EOF >> /etc/defined/dnctl
DN_IP_ADDRESS=${DN_IP_ADDRESS}
EOF
    fi

    if [[ "${DN_NETWORK_NAME}" ]]; then
        cat << EOF >> /etc/defined/dnctl
DN_NETWORK_NAME=${DN_NETWORK_NAME}
EOF
    fi

    if [[ "${DN_HOSTNAME}" ]]; then
        cat << EOF >> /etc/defined/dnctl
DN_HOSTNAME=${DN_HOSTNAME}
EOF
    fi

    if [[ "${DN_CLOUD_PROVIDER}" ]]; then
        cat << EOF >> /etc/defined/dnctl
DN_CLOUD_PROVIDER=${DN_CLOUD_PROVIDER}
EOF
    fi

    if [[ "${DN_STATIC_ADDRESSES}" ]]; then
        cat << EOF >> /etc/defined/dnctl
DN_STATIC_ADDRESSES='${DN_STATIC_ADDRESSES}'
EOF
    fi

    if [[ "${DN_LISTEN_PORT}" ]]; then
        cat << EOF >> /etc/defined/dnctl
DN_LISTEN_PORT=${DN_LISTEN_PORT}
EOF
    fi

    if [[ "${DN_IS_LIGHTHOUSE}" == "true" ]]; then
        cat << EOF >> /etc/defined/dnctl
DN_IS_LIGHTHOUSE=${DN_IS_LIGHTHOUSE}
EOF
    fi

    if [[ "${DN_IS_RELAY}" == "true" ]]; then
        cat << EOF >> /etc/defined/dnctl
DN_IS_RELAY=${DN_IS_RELAY}
EOF
    fi

    chmod 0640 /etc/defined/dnctl
}

enroll(){
    [[ -v DN_API_KEY ]] || { echo "DN_API_KEY is unset! Exiting!"; exit 1; }
    [[ -v DN_NETWORK_ID ]] || { echo "DN_NETWORK_ID is unset! Exiting!"; exit 1; }
    [[ -v DN_ROLE_ID ]] || { echo "DN_ROLE_ID is unset! Exiting!"; exit 1; }
    [[ ${DN_API_KEY} ]] || { echo "DN_API_KEY is empty! Exiting!"; exit 1; }
    [[ ${DN_NETWORK_ID} ]] || { echo "DN_NETWORK_ID is empty! Exiting!"; exit 1; }
    [[ ${DN_ROLE_ID} ]] || { echo "DN_ROLE_ID is empty! Exiting!"; exit 1; }

    # Validate lighthouse/relay mutual exclusion
    if [[ "${DN_IS_LIGHTHOUSE}" == "true" && "${DN_IS_RELAY}" == "true" ]]; then
        echo "DN_IS_LIGHTHOUSE and DN_IS_RELAY cannot both be true! Exiting!"
        exit 1
    fi

    # Validate lighthouse requires staticAddresses
    if [[ "${DN_IS_LIGHTHOUSE}" == "true" && -z "${DN_STATIC_ADDRESSES}" ]]; then
        echo "DN_STATIC_ADDRESSES is required when DN_IS_LIGHTHOUSE is true! Exiting!"
        exit 1
    fi

    # Validate lighthouse/relay requires listenPort
    if [[ "${DN_IS_LIGHTHOUSE}" == "true" || "${DN_IS_RELAY}" == "true" ]]; then
        if [[ -z "${DN_LISTEN_PORT}" || "${DN_LISTEN_PORT}" == "0" ]]; then
            echo "DN_LISTEN_PORT must be a non-zero port for lighthouses and relays! Exiting!"
            exit 1
        fi
    fi

    if [[ -f "$CONFIG_PATH" ]]; then
        echo "$CONFIG_PATH found! Host is already enrolled locally. Skipping enrollment..."
        exit 0
    fi

    if ! systemctl is-active --quiet "$SERVICE_NAME"; then
        echo "$SERVICE_NAME is not running! Exiting!"
        exit 1
    fi

    # Build enrollment hostname
    # Start with DN_HOSTNAME or system hostname
    if [[ "${DN_HOSTNAME}" ]]; then
        ENROLLMENT_HOSTNAME="${DN_HOSTNAME}"
    else
        ENROLLMENT_HOSTNAME="$(hostname)"
    fi

    # Append cloud instance ID if DN_CLOUD_PROVIDER is set
    if [[ "${DN_CLOUD_PROVIDER}" ]]; then
        INSTANCE_ID=$(get_instance_id "${DN_CLOUD_PROVIDER}")
        if [[ -n "${INSTANCE_ID}" ]]; then
            ENROLLMENT_HOSTNAME="${ENROLLMENT_HOSTNAME}-${INSTANCE_ID}"
        else
            echo "Warning: Failed to get instance ID from ${DN_CLOUD_PROVIDER}" >&2
        fi
    fi

    # Check if host with this name is already enrolled in defined.net
    echo "Checking if host '${ENROLLMENT_HOSTNAME}' is already enrolled..."
    EXISTING_HOST=$(curl -H user-agent:defined-systemd-units -s -L \
        "https://api.defined.net/v1/hosts?networkID=${DN_NETWORK_ID}&name=${ENROLLMENT_HOSTNAME}" \
        -H "Accept: application/json" \
        -H "Authorization: Bearer ${DN_API_KEY}" | jq -r '.data[0].id // empty')

    if [[ -n "${EXISTING_HOST}" ]]; then
        echo "Host '${ENROLLMENT_HOSTNAME}' is already enrolled in defined.net (ID: ${EXISTING_HOST}). Skipping enrollment..."
        exit 0
    fi

    # Build configOverrides array with tun.dev
    CONFIG_OVERRIDES=$(jq --compact-output --null-input \
        --arg tundev "${DN_NETWORK_NAME}" \
        '[{"key": "tun.dev", "value": $tundev}]')

    # Set tags
    if [[ "${DN_TAGS}" ]]; then
        DN_TAG_LIST="${DN_TAGS}"
    else
        DN_TAG_LIST='[]'
    fi

    # Set staticAddresses for lighthouse enrollment
    if [[ "${DN_STATIC_ADDRESSES}" ]]; then
        DN_STATIC_ADDRESSES_LIST="${DN_STATIC_ADDRESSES}"
    else
        DN_STATIC_ADDRESSES_LIST='[]'
    fi

    # Set listenPort (default 0 lets the system choose)
    if [[ "${DN_LISTEN_PORT}" ]]; then
        LISTEN_PORT="${DN_LISTEN_PORT}"
    else
        LISTEN_PORT=0
    fi

    # Set isLighthouse boolean
    if [[ "${DN_IS_LIGHTHOUSE}" == "true" ]]; then
        IS_LIGHTHOUSE="true"
    else
        IS_LIGHTHOUSE="false"
    fi

    # Set isRelay boolean
    if [[ "${DN_IS_RELAY}" == "true" ]]; then
        IS_RELAY="true"
    else
        IS_RELAY="false"
    fi

    # Build enrollment JSON
    ENROLLMENT_DATA=$(jq --compact-output --null-input \
        --arg name "${ENROLLMENT_HOSTNAME}" \
        --arg networkID "${DN_NETWORK_ID}" \
        --arg roleID "${DN_ROLE_ID}" \
        --arg ipAddress "${DN_IP_ADDRESS}" \
        --argjson listenPort "${LISTEN_PORT}" \
        --argjson isLighthouse "${IS_LIGHTHOUSE}" \
        --argjson isRelay "${IS_RELAY}" \
        --argjson tags "${DN_TAG_LIST}" \
        --argjson staticAddresses "${DN_STATIC_ADDRESSES_LIST}" \
        --argjson configOverrides "${CONFIG_OVERRIDES}" \
        '{name: $name, networkID: $networkID, roleID: $roleID, listenPort: $listenPort, isLighthouse: $isLighthouse, isRelay: $isRelay, tags: $tags, configOverrides: $configOverrides} + (if $ipAddress != "" then {ipAddress: $ipAddress} else {} end) + (if ($staticAddresses | length) > 0 then {staticAddresses: $staticAddresses} else {} end)')
    echo "Enrollment Data: ${ENROLLMENT_DATA}"

    ENROLLMENT_RESPONSE=$(curl -H user-agent:defined-systemd-units -s -L -X POST 'https://api.defined.net/v1/host-and-enrollment-code' \
    -H 'Content-Type: application/json' \
    -H 'Accept: application/json' \
    -H "Authorization: Bearer ${DN_API_KEY}" \
    --data-raw "${ENROLLMENT_DATA}")
    echo "Enrollment Response: ${ENROLLMENT_RESPONSE}"

    ENROLLMENT_CODE=$(echo "${ENROLLMENT_RESPONSE}" | jq -r .data.enrollmentCode.code)
    echo "Enrollment Code: ${ENROLLMENT_CODE}"

    echo "Enrolling Host: $(echo "${ENROLLMENT_RESPONSE}" | jq -r .data.host.id)"
    dnclient enroll -name "$DN_NETWORK_NAME" -code "${ENROLLMENT_CODE}"
}

unenroll(){
    [[ -v DN_API_KEY ]] || { echo "DN_API_KEY is unset! Exiting!"; exit 1; }
    [[ ${DN_API_KEY} ]] || { echo "DN_API_KEY is empty! Exiting!"; exit 1; }

    if [[ "${DN_SKIP_UNENROLL}" == "true" ]]; then
        echo "DN_SKIP_UNENROLL set to true. Skipping unenroll!"
        exit 0
    fi

    # Skip unenrollment on reboot unless explicitly configured to unenroll
    if is_rebooting; then
        if [[ "${DN_UNENROLL_ON_REBOOT}" != "true" ]]; then
            echo "System is rebooting. Skipping unenroll (set DN_UNENROLL_ON_REBOOT=true to override)."
            exit 0
        fi
        echo "System is rebooting but DN_UNENROLL_ON_REBOOT=true. Proceeding with unenroll..."
    fi

    if [[ -f "$CONFIG_PATH" ]]; then
        DN_HOST_ID=$(grep -F host_id "$CONFIG_PATH" | awk '{ print $2 }' | head -1 )
    else
        echo "$CONFIG_PATH is not found! Is this host enrolled? Exiting.."
        exit 1
    fi

    echo "Unenrolling host: ${DN_HOST_ID}"
    curl -H user-agent:defined-systemd-units -sSL -X DELETE "https://api.defined.net/v1/hosts/${DN_HOST_ID}" \
    -H "Accept: application/json" \
    -H "Authorization: Bearer ${DN_API_KEY}"

    # Stop dnclient, remove config directory, and restart to fully clear state
    CONFIG_DIR="/etc/defined/${DN_NETWORK_NAME}"
    echo "Stopping ${SERVICE_NAME}..."
    systemctl stop "$SERVICE_NAME" || true
    echo "Removing config directory: ${CONFIG_DIR}"
    rm -rf "$CONFIG_DIR"
    echo "Starting ${SERVICE_NAME}..."
    systemctl start "$SERVICE_NAME" || true
}

reenroll(){
    unenroll
    enroll
}

helptext(){
cat <<'EOF'

dnctl: The unofficial Swiss Army knife for defined.net

usage: dnctl command

commands:
    install: Download and install dnclient to /usr/local/bin
    start: Start dnclient service
    stop: Stop dnclient service
    restart: Restart dnclient service
    enable: Enable dnclient service
    write_config: Write environment variables to /etc/defined/dnctl
    enroll: Enroll the host into defined.net
    unenroll: Unenroll the host from defined.net
    reenroll: Unenroll and Enroll the host
    help: Show this message

environment variables:
    DN_API_KEY: API key for defined.net (required)
    DN_NETWORK_ID: Network ID to enroll into (required)
    DN_ROLE_ID: Role ID to assign to host (required)
    DN_NETWORK_NAME: Network name for instantiated services (default: defined)
        - Uses dnclient@${DN_NETWORK_NAME}.service
        - Uses /etc/defined/${DN_NETWORK_NAME}/dnclient.yml
        - Sets tun.dev interface to ${DN_NETWORK_NAME}
    DN_HOSTNAME: Base display name in defined.net admin (defaults to hostname)
    DN_CLOUD_PROVIDER: Cloud provider for instance ID (aws, gcp, azure)
        When set, appends instance ID to hostname for unique names
        Example: host + i-093adcbbbee1cbbb1 = host-093adcbbbee1cbbb1
    DN_IP_ADDRESS: Static IP address for the host (optional)
    DN_TAGS: JSON array of tags, e.g. '["role:server","env:prod"]'
    DN_SKIP_UNENROLL: Set to "true" to skip unenrollment on stop
    DN_UNENROLL_ON_REBOOT: Set to "true" to unenroll even on reboot (default: false)
        By default, hosts are preserved during reboot and only unenrolled on shutdown

lighthouse/relay enrollment:
    DN_IS_LIGHTHOUSE: Set to "true" to enroll as a lighthouse
        Requires DN_STATIC_ADDRESSES and DN_LISTEN_PORT
        Cannot be used with DN_IS_RELAY
    DN_IS_RELAY: Set to "true" to enroll as a relay
        Requires DN_LISTEN_PORT
        Cannot be used with DN_IS_LIGHTHOUSE
    DN_STATIC_ADDRESSES: JSON array of public IP:port for lighthouse discovery
        Example: '["84.123.10.1:4242"]' or '["84.123.10.1:4242","[2001:db8::1]:4242"]'
        Required when DN_IS_LIGHTHOUSE is true
    DN_LISTEN_PORT: UDP port for the host to listen on (0 = auto-select)
        Required non-zero value for lighthouses and relays

EOF
}

case "$1" in
    install)
        install_dnclient
        ;;
    start)
        start
        ;;
    stop)
        stop
        ;;
    restart)
        restart
        ;;
    enable)
        enable
        ;;
    write_config)
        write_config
        ;;
    enroll)
        enroll
        ;;
    unenroll)
        unenroll
        ;;
    reenroll)
        reenroll
        ;;
    help)
        helptext
        exit 0
        ;;
    *)
        echo "Unknown command!"
        helptext
        exit 1
        ;;
esac
